package com.chasedelanguillette.utils{	import com.chasedelanguillette.utils.MersenneTwister;		/**	 *	A collection of handy functions for manipulating arrays.	 *	 *	@langversion ActionScript 3.0	 *	@playerversion Flash 9.0	 *	 *	@author ${TM_FULLNAME}	 *	@since  ${TM_DATE}	 */	public class ArrayUtils	{				/**		*	something something something		*/		public static const ARRAY_MASTER:int = 0;				//============================================		//	Array creation		//============================================		/**		* Creates a new 2 dimensional array, and fills each cell in the array with the user defined contents		*			*	@param w The width of the 2 dimensional array that will be created.		*	@param h The height of the 2 dimensional array that will be created.		*	@param contents The contents that will be put in each cell of the new 2 dimensional array that will be created.		*			*	@return A 2 dimensional array of specified dimensions that contains user defined contents.		*/		public static function newArray2D(w:int, h:int, contents:*):Array		{			var blankMap:Array = new Array();			for (var i:int = 0; i < h; i++)			{				blankMap[i] = new Array();				for (var j:int = 0; j < w; j++)				{					blankMap[i][j] = contents;				}			};			return blankMap;		};						//==========================================================		// array randomization		//==========================================================				/**		* Shuffles an existing array randomly, without creating a new copy of the original array		*			*	@param arr The Array that will be shuffled randomly.		*			*	@return Returns the original array, shuffled randomly.		*			*	@see shuffleArrayWithNumberGenerator		*/		public static function shuffleArray (arr:Array):Array		{			var len:int = arr.length;			var temp:*;			var i:int = len;			while (i--)			{				var rand:int = Math.floor(Math.random() * len);				temp = arr[i];				arr[i] = arr[rand];				arr[rand] = temp;			}			return arr;		};				/**		* Shuffles an array with a random number generator, for more reproducible shuffles.		*			*	@param arr The Array you wish to shuffle.		*	@param oNumberGenerator The random number generator being utilized for the random shuffle		*			*	@return Returns the original array, shuffled randomly.		*			*	@see shuffleArray		*/		public static function shuffleArrayWithNumberGenerator (arr:Array, oNumberGenerator:MersenneTwister):Array		{			var len:int = arr.length;			var temp:*;			var i:int = len;			while (i--)			{				var fRandom:Number = MersenneTwister.nGenerateRandomFloatFromInstance(oNumberGenerator);				var rand:int = Math.floor(fRandom * len);				temp = arr[i];				arr[i] = arr[rand];				arr[rand] = temp;			}			return arr;		}						//==========================================================		// 2d array transformations		//==========================================================				/**		* Returns a new array that is a transformed version of the parameter 'array'. 		*/		public static function getNewRandomlyTransformedArray2D(array:Array):Array		{			var transformedArray:Array = aoCopyArray2D(array);			randomlyTransformArray2D(transformedArray);			return transformedArray;				};				/**		* Takes the array and randomly transforms it. 		*/		public static function randomlyTransformArray2D(array:Array):Array		{			var transformedArray:Array = array;						var rotation:int = Math.floor(Math.random() * 4)			switch (rotation)			{				case 0 :					// rotation none				break;				case 1 :					// rotate 90					transformedArray = aoRotateRight(transformedArray);				break;				case 2 :					// rotate 180					transformedArray = aoRotateRight(transformedArray);					transformedArray = aoRotateRight(transformedArray);				break;				case 3 :					// rotate 270					transformedArray = aoRotateRight(transformedArray);					transformedArray = aoRotateRight(transformedArray);					transformedArray = aoRotateRight(transformedArray);				break;			}			var reflect_h:int = Math.floor(Math.random() * 2);			if ( reflect_h == 0 ) transformedArray = aoFlipHorizontal(transformedArray);			var reflect_v:int = Math.floor(Math.random() * 2);			if ( reflect_v == 0 ) transformedArray = aoFlipVertical(transformedArray);			return transformedArray;		}				/**		*	Flips a 2d array horizontally. 		*/		public static function aoFlipHorizontal(array:Array):Array		{			var transformedArray:Array = new Array();						for ( var i:int = 0; i < array.length; i++ )			{				transformedArray[i] = new Array();								var index:int = 0;				for ( var j:int = array[0].length - 1; j > -1; j-- )				{					transformedArray[i][index] = array[i][j];					index++;				}			}						return transformedArray;		}				/**		*	Flips a 2d array vertically. 		*			*			*/		public static function aoFlipVertical(array:Array):Array		{			var transformedArray:Array = new Array();						for ( var i:int = array.length - 1; i > -1; i-- )			{				transformedArray.push( array[i] );			}						return transformedArray;		}				public static function aoRotateRight(array:Array):Array		{			var transformedArray:Array = new Array();							for ( var i:int = 0; i < array[0].length; i++ )			{				transformedArray[i] = new Array();								// fill the row with everything in the appropriate column of the source array				var transformedArrayColumn:int = -1;				for ( var j:int = array.length - 1; j > -1; j-- )				{					transformedArrayColumn++;					transformedArray[i][transformedArrayColumn] = array[j][i]				}					}						return transformedArray;		}				public static function aoRotateLeft(array:Array):Array		{			var transformedArray:Array = new Array();						var row:int = -1;			for ( var i:int = array[0].length - 1; i > -1; i-- )			{				row++;				transformedArray[row] = new Array();								for ( var j:int = 0; j < array.length; j++ )				{					transformedArray[row][j] = array[j][i];				}			}						return transformedArray;		};						//============================================		//	Pasting Arrays Into other Arrays		//============================================				public static function pasteArray2D(clipboardArray:Array, destinationArray:Array, x:int, y:int):void		{			for (var i:int = y; i < y + clipboardArray.length; i++)			{				for (var j:int = x; j < x + clipboardArray[i - y].length; j++)				{					// ensure we're pasting in valid indeces					if ( i < destinationArray.length && j < destinationArray[0].length ) destinationArray[i][j] = clipboardArray[i - y][j - x];				}			}		};						/**		*	chase :: this looks kind of weird.		*/		public static function pasteArray(clipboardArray:Array, destinationArray:Array, startIndex:int):void		{			for (var i:int = startIndex; i < startIndex + clipboardArray.length; i++)			{				if ( i < destinationArray.length - 1 ) destinationArray[i] = clipboardArray[i - startIndex];			}		};						//============================================		//	Tracing Arrays		//============================================		public static function traceArray2D(arr:Array):void		{			for (var i:int = 0; i < arr.length; i++)			{				trace(arr[i])			}		};						//==========================================================		// Array duplication		//==========================================================				public static function aoCopyArray2D(array:Array):Array		{			var newMap:Array = new Array();						for (var y:int = 0; y < array.length; y++)			{				newMap[y] = new Array();				for (var x:int = 0; x < array[0].length; x++)				{					newMap[y][x] = array[y][x];				}			}						return newMap;		};				public static function aoCopyArray(array:Array):Array		{			var newArr:Array = new Array();			for (var i:int = 0; i < array.length; i++)			{				newArr[i] = array[i];				}			return newArr;		};				public static function pasteArrayInto(source:Array, destination:Array, pasteIndex:int = 0):void		{			for(var i:int = 0; i < source.length; i++) destination[i] = source[i + pasteIndex];		}						//==========================================================		// Array searching		//==========================================================				// figures out of the desired x, y coords are in the range of our 2d array.		public static function inArray2DBounds(arr:Array, x:int, y:int):Boolean		{			if (arr.length == 0) return false;			if (x < 0) return false;			if (y < 0) return false;			if (y >= arr.length) return false;			if (x >= arr[0].length) return false;			return true;		}				public static function bIsObjectInArray(object:*, array:Array):Boolean		{			for (var i:int = 0; i < array.length; i++)			{				if ( array[i] == object ) return true;			}			return false;		};				public static function bIsObjectInArray2D(object:*, array:Array):Boolean		{			for (var i:int = 0; i < array.length; i++)			{				for (var j:int = 0; j < array[0].length; j++)				{					if ( array[i][j] == object ) return true;				}			}			return false;		};	}}