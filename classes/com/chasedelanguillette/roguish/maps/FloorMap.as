/////////////////////////////////////////////////////	FloorMap//	CREATED: 2009-08-23.//	BY: CHASE DE LANGUILLETTE - chase.delanguillette@gmail.com////	CLASS RESPONSIBILITES://////////////////////////////////////////////////////package com.chasedelanguillette.roguish.maps{	//============================================	//	CUSTOM IMPORTS	//============================================		import com.chasedelanguillette.roguish.maps.Minimap;	import com.chasedelanguillette.roguish.characters.Mobile;				import com.chasedelanguillette.roguish.objects.intangibles.Hero;	import com.chasedelanguillette.roguish.objects.physicalObjects.PhysicalObject;	import com.chasedelanguillette.roguish.objects.physicalObjects.living.LivingObject;	import com.chasedelanguillette.roguish.objects.physicalObjects.living.humanoid.Humanoid;		import com.chasedelanguillette.roguish.objects.intangibles.ObjectFactory;			//============================================	//	STANDARD IMPORTS	//============================================			public class FloorMap	{				//============================================		//	CONSTANTS		//============================================								//============================================		//	PUBLIC VARS		//============================================										//============================================		//	PRIVATE VARS		//============================================				public var tiles:Array;			// a 2d array of ints describing the tile data		public var tileObjects:Array;		public var rooms:Array;			// a 2d array of MapData objects		public var minimap:Minimap;		// Minimap object		private var _monsters:Array;	// 		private var _items:Array;		// 		private var _oHero:Hero = new Hero();		private var _aoHeros:Array = [_oHero];						//////////////////////////////////////////////		//		//	CONSTRUCTOR		//		//////////////////////////////////////////////				/**		*	@constructor		*/		public function FloorMap(tiles:Array = null, roomData:Array = null, minimap:Minimap = null, monsters:Array = null, items:Array = null):void		{			this.tiles 		= tiles;			this.rooms		= roomData;			this.minimap 	= minimap;						_monsters 		= monsters;			if (_monsters == null) _monsters = new Array();						_items 			= items;			if (_items == null) _items = new Array();					};				//////////////////////////////////////////////		//		//	PUBLIC METHODS		//		//////////////////////////////////////////////				/**		*	Forces all of the floor map's data into garbage collection.		*/		public function cleanUp():void		{			var i:int;			var j:int;						if (this.tiles != null)			{				for (i = 0; i < this.tiles.length; i++)				{					this.tiles[i] = null;				}				this.tiles = null;			}						if (rooms != null )			{				for (i = 0; i < rooms.length; i++)				{					for (j = 0; j < rooms[i].length; j++)					{						if (rooms[i][j] != null)						{							rooms[i][j].cleanUp();							rooms[i][j] = null;						}					}									}				rooms = null;			}						if ( this.minimap != null )			{				for (i = 0; i < this.minimap.aoMapLayout.length; i++)				{					for (j = 0; j < this.minimap.aoMapLayout[0].length; j++)					{						this.minimap.aoMapLayout[i][j] = null;					}				}								this.minimap.aoMapLayout = null;			}		};						/**		*	Adds a monster to the map.		*			*	<p>Doesn't add the monster to the grid of tile objects yet.</p>		*/		public function addMonster(oMonster:Object):void		{			//trace("FloorMap::addMonster()");			if (_monsters == null) _monsters = new Array();			/*			var m:Mobile = new Mobile();			m.tx = oMonster.tx;			m.ty = oMonster.ty;			m.id = oMonster.type;			*/			var m:LivingObject = ObjectFactory.makeCreature(oMonster.type) as LivingObject;//new Humanoid() as LivingObject;			m.setPosition(oMonster.tx, oMonster.ty);			_monsters.push(m)						// Fri Oct  2 08:44:33 CDT 2009 CMD TODO: figure out a more versatile way to do this.			// this is going to be ruined if you make a two player game!			switch(oMonster.type)			{				case Mobile.HERO :					trace("FloorMap::addMonster() -> HERO ADDED!!!");					_oHero.oPhysicalObject = m;					_oHero.oPhysicalObject.bIsFocused = true;										//m.bTrackMoves = true;					//m.nEnergyPerTurn = 15;				break;			}			//_occupied[oMonster.ty][oMonster.tx] = true;		};						/**		*	Adds an item to the map.		*/		public function addItem(oItem:Object):void		{			if(_items == null) _items = new Array();						var i:PhysicalObject = ObjectFactory.makeObject(-1) as PhysicalObject;			i.setPosition(oItem.tx, oItem.ty);						/*			i.type = oItem.id;			i.tx = oItem.tx;			i.ty = oItem.ty;			*/			_items.push(i);		}						/**		*	creates tile objects for EVERY tile on the map.		*/		public function makeTileObjects():void		{			tileObjects = new Array();			for (var i:int = 0; i < tiles.length; i++)			{				tileObjects[i] = new Array();				for (var j:int = 0; j < tiles[i].length; j++)				{					tileObjects[i][j] = ObjectFactory.makeObject(PhysicalObject.FLOOR);//{monster:null, item:null};				}			}		};						/**		*	Places every monster on a tile.		*/		public function placeMonstersOnTiles():void		{			for (var i:int = 0; i < _monsters.length; i++)			{				var m:LivingObject = _monsters[i] as LivingObject;				tileObjects[m.oDimensions.y][m.oDimensions.x].monster = m;			}		};						/**		*	moves a monster from one tile to another.		*/		public function handleMonsterMove(m:LivingObject, tx:int, ty:int):void		{			tileObjects[m.oDimensions.y][m.oDimensions.x].monster = null;			tileObjects[ty][tx].monster = m;		};						/**		*	Indicates whether the tile contains a monster.		*/		public function bTileContainsMonster(tx:int, ty:int):Boolean		{			if (tileObjects[ty][tx].monster != null) return true;			return false		};						public function getMonsterAt(tx:int, ty:int):PhysicalObject		{			return tileObjects[ty][tx].monster as PhysicalObject;		}				/**		*	Indicates whether the tile contains an item.		*/		public function bTileContainsItem(tx:int, ty:int):Boolean		{			if (tileObjects[ty][tx].item != null) return true;			return false		};				public function getItemAt(tx:int, ty:int):PhysicalObject		{			return tileObjects[ty][tx].item as PhysicalObject;		};						/**		*	Removes any item located at the speccified tile.		*/		public function removeItemAt(tx:int, ty:int):Object		{			var item:Object = tileObjects[ty][tx].item;			tileObjects[ty][tx] = null;			return item;		};						/**		*	Adds a specified item to the map at an exact location.		*/		public function addItemAt(item:Object, tx:int, ty:int):void		{					};						//////////////////////////////////////////////		//		//	GETTERS		//		//////////////////////////////////////////////				/**		*	Array of monsters currently on the floor.		*/		public function get monsters():Array{			return _monsters;		};						/**		*	Array of items currently on the floor.		*/		public function get items():Array{			return _items;		};						/**		*	Gets the hero object for this map.		*/		public function get oHero():Object{			return _oHero;		}						//////////////////////////////////////////////		//		//	SETTERS		//		//////////////////////////////////////////////								//////////////////////////////////////////////		//		//	EVENT HANDLERS		//		//////////////////////////////////////////////								//////////////////////////////////////////////		//		//	PRIVATE METHODS		//		//////////////////////////////////////////////					}}