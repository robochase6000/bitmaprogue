/////////////////////////////////////////////////////	MazeCreatorTest//	CREATED: 2009-8-10//	BY: CHASE DE LANGUILLETTE - chase.delanguillette@gmail.com////	CLASS RESPONSIBILITES://	* The only thing you need to know about this class is that you can call aoGenerateMaze, and it will return a randomly generated maze as a 2d array.//////////////////////////////////////////////////////package com.chasedelanguillette.roguish.maps.building{	//============================================	//	CUSTOM IMPORTS	//============================================	import com.chasedelanguillette.utils.ArrayUtils;	import com.chasedelanguillette.utils.MersenneTwister;	import com.chasedelanguillette.roguish.maps.Minimap;	import com.chasedelanguillette.roguish.maps.sections.Tile;			//============================================	//	STANDARD IMPORTS	//============================================	import flash.utils.getTimer;			public class MazeCreator	{				//============================================		//	CONSTANTS		//============================================				// don't touch!		private static var _oRandomNumberGenerator:MersenneTwister;		public static const CELL_VISITED:int 				= 0;		public static const DIR_N:int 						= 1;         		public static const DIR_S:int 						= 2;         		public static const DIR_E:int 						= 3;         		public static const DIR_W:int 						= 4;         		                                                     			//============================================		//	PUBLIC METHODS		//============================================		public static function cleanUp():void		{			if ( _oRandomNumberGenerator != null )			{				_oRandomNumberGenerator = null;			}		}		/**		*	@fDeadEndsRemoved is a float from 0..1. it represents the percentage chance a dead end has of being removed. A random wall in the dead end room will be knocked down		*		The dead end removal process only occurs one time, right now.  A improvement would be to repeat the process n times.		*	@fSparseness is a float from 0..1.  it represents the percentage chance a dead end room will be sealed off.		*		The sparseness process only occurs one time right now.  An improvement would be to repeat the process n times.		*	@fAdditionalWallsDestroyed is a float from 0..1. After dead ends are removed and sparseness is applied to the maze, we make a pass through every wall in the maze,		*		testing it against fAdditionalWallsDestroyed.  If it fails to pass the test, the wall is destroyed.		*		For example, setting this parameter to 1.0 would destroy every wall in the maze while setting it to 0.25 means 25% of all remaining walls will be destroyed.		*/		public static function aoGenerateMaze(oRandomNumberGenerator:MersenneTwister, nWidth:int, nHeight:int, fDeadEndsRemoved:Number = 0, fSparseness:Number = 0, fAdditionalWallsDestroyed:Number = 0):Minimap		{			var startTime:int;			var endTime:int;			startTime = getTimer();						_oRandomNumberGenerator 	= oRandomNumberGenerator;						var aoMaze:Array 			= newMaze(nWidth, nHeight, fDeadEndsRemoved, fSparseness, fAdditionalWallsDestroyed);			var oMinimap:Minimap 		= new Minimap(aoMaze, nWidth, nHeight);									endTime = getTimer();			trace("MazeCreatorTest::aoGenerateMaze() -> maze created in " + (endTime - startTime) + " ms.");						return oMinimap;		};								//============================================		//	PRIVATE METHODS		//============================================		// nSparseness parameter - set how many dead ends in the maze you want to be eliminated.  if set to -1, the maze will have no dead ends!		private static function newMaze(w:int, h:int, fDeadEndsRemoved:Number = 0, fSparseness:Number = 0, fAdditionalWallsDestroyed:Number = 0):Array		{			var aoMaze:Array = new Array();			var aoMoves:Array = new Array();			var nCellCount:int = w * h;									// chuse a random starting position			var nCurrentPosition:int = Math.floor( MersenneTwister.nGenerateRandomFloatFromInstance(_oRandomNumberGenerator) * nCellCount );						// I am on a cell, so I visited one. Let's count visited cells...			var nVisited:int = 1;						// for every cell, mark it as unvisited with walls on all sides			for (var i:int = 0; i < nCellCount; i++)			{				aoMaze[i] = new Array();				aoMaze[i][CELL_VISITED] = 0;				aoMaze[i][DIR_N] = 1;				aoMaze[i][DIR_S] = 1;				aoMaze[i][DIR_E] = 1;				aoMaze[i][DIR_W] = 1;			}						// marking the cell I am on as visited			aoMaze[nCurrentPosition][CELL_VISITED] = 1;						// loop to be executed until all cells have been visited			while ( nVisited < nCellCount ) {				// check for possible moves				var szPossibleDirections = "";												// possible move at west				if ((Math.floor(nCurrentPosition/w) == Math.floor((nCurrentPosition-1)/w)) && (aoMaze[nCurrentPosition-1][0] == 0)) {					szPossibleDirections = szPossibleDirections+"W";				}												// possible move at east				if ((Math.floor(nCurrentPosition/w) == Math.floor((nCurrentPosition+1)/w)) && (aoMaze[nCurrentPosition+1][0] == 0)) {					szPossibleDirections = szPossibleDirections+"E";				}								// possible move at south								if (((nCurrentPosition + w) < nCellCount) && (aoMaze[nCurrentPosition + w][0] == 0)) {					szPossibleDirections = szPossibleDirections+"S";				}								// possible move at north				if (((nCurrentPosition-w)>=0) && (aoMaze[nCurrentPosition-w][0] == 0)) {					szPossibleDirections = szPossibleDirections+"N";				}												// if a move exists, crash a wall && mark new cell as visited     				if (szPossibleDirections) {					// increasing number of visited cells					nVisited++;					// saving my position the moves array					aoMoves.push(nCurrentPosition);					// choosing a random direction					var szRandomDirection = szPossibleDirections.charAt(Math.floor(MersenneTwister.nGenerateRandomFloatFromInstance(_oRandomNumberGenerator)*szPossibleDirections.length));					switch (szRandomDirection) {						case "N" :							// going north: crashing walls and updating position							aoMaze[nCurrentPosition][DIR_N] 				= 0;							aoMaze[nCurrentPosition-w][DIR_S] 	= 0;							nCurrentPosition -= w;						break;						case "S" :							// going south: crashing walls and updating position							aoMaze[nCurrentPosition][DIR_S] 				= 0;							aoMaze[nCurrentPosition+w][DIR_N] 	= 0;							nCurrentPosition += w;						break;						case "E" :							// going east: crashing walls and updating position							aoMaze[nCurrentPosition][DIR_E] 				= 0;							aoMaze[nCurrentPosition+1][DIR_W] 				= 0;							nCurrentPosition++;						break;						case "W" :							// going west: crashing walls and updating position							aoMaze[nCurrentPosition][DIR_W] 				= 0;							aoMaze[nCurrentPosition-1][DIR_E] 				= 0;							nCurrentPosition--;						break;					}					// set the cell as visited					aoMaze[nCurrentPosition][CELL_VISITED] = 1;					// if I cannot movie anymore, backtrack to a previously saved cell				} else {					nCurrentPosition = aoMoves.pop();				}			}// end while loop						// Now take are lame 1d maze array and make it a 2d array!			var aoMaze2d:Array = new Array();			var aoDeadEnds:Array = new Array();			var nCurrentTileIndex:int = 0;						for (i = 0; i < h; i++)			{				aoMaze2d[i] = new Array();								for (var j:int = 0; j < w; j++)				{					aoMaze2d[i][j] = new Tile();					var t:Tile = aoMaze2d[i][j];										t.tx = j;					t.ty = i;								var tileInMaze = aoMaze[nCurrentTileIndex];										t.bWall_Up 		= Boolean(tileInMaze[DIR_N]);					t.bWall_Down 	= Boolean(tileInMaze[DIR_S]);					t.bWall_Left 	= Boolean(tileInMaze[DIR_W]);					t.bWall_Right 	= Boolean(tileInMaze[DIR_E]);										t.bWalkable 	= true;										// build up an array of dead end tiles that will be looked over when we apply sparseness!					if ( nWallCount(t) == 3 ) aoDeadEnds.push(t);										nCurrentTileIndex++;				}			}						applySparseness(aoMaze2d, aoDeadEnds, fSparseness);					removeDeadEnds(aoMaze2d, aoDeadEnds, fDeadEndsRemoved);			destroyWalls(aoMaze2d, fAdditionalWallsDestroyed);						return aoMaze2d;		}// end newMaze function						private static function nWallCount(t:Tile):int		{			var nWalls:int = 0;			if (t.bWall_Up) nWalls++;			if (t.bWall_Down) nWalls++;			if (t.bWall_Left) nWalls++;			if (t.bWall_Right) nWalls++;			return nWalls;		};				private static function applySparseness(aoMaze2d:Array, aoDeadEnds:Array, fSparseness:Number):void		{			var bDebug:Boolean = false;			// loop through all dead ends.			// 		if sparseness > randomChance			//			seal the dead end.			//			add wall at its neighbor			//		else			var l:int = aoDeadEnds.length;			for (var i:int = 0; i < l; i++)			{				if ( fSparseness > MersenneTwister.nGenerateRandomFloatFromInstance(_oRandomNumberGenerator) )				{										// seal th dead end.					var t:Tile = aoDeadEnds[0];					var n:Tile;// neighbor of current tile					var bRemovalSuccess:Boolean = false;					var nx:int = t.tx;					var ny:int = t.ty;										if ( bDebug ) trace( "****************** attempting removal! tx: " + t.tx + " ty: " + t.ty)										switch(false)					{						case t.bWall_Up:														// get neighbor							ny--;							//trace( "no up nx: " + nx + " ny: " + ny)							if ( ny >= 0 ){								t.bWall_Up = true;								n = aoMaze2d[ny][nx]								n.bWall_Down = true;								bRemovalSuccess = true;							}						break;						case t.bWall_Down:							// get neighbor too							ny++;							//trace( "no down nx: " + nx + " ny: " + ny)							if ( ny < aoMaze2d.length ){								t.bWall_Down = true;								n = aoMaze2d[ny][nx]								n.bWall_Up = true;								bRemovalSuccess = true;							}						break;						case t.bWall_Left:							// get neighbor too							nx--;							//trace( "no left nx: " + nx + " ny: " + ny)							if ( nx >= 0 ){								t.bWall_Left = true;								n = aoMaze2d[ny][nx];								n.bWall_Right = true;								bRemovalSuccess = true;							}						break;						case t.bWall_Right:							// get neighbor too.							nx++;							//trace( "no right nx: " + nx + " ny: " + ny)							if ( nx < aoMaze2d[0].length ){								t.bWall_Right = true;								n = aoMaze2d[ny][nx];								n.bWall_Left = true;								bRemovalSuccess = true;							}						break;					}										if (bRemovalSuccess)					{						if ( bDebug ) trace( "****************** sparseness applied!")						aoDeadEnds.shift()//(i, 1);						t.bWalkable = false;					}					else					{						if ( bDebug ) trace( "****************** sparseness failed!")					}				}				else				{					if ( bDebug ) trace( "****************** sparseness failed @random chance!")				}			}		}				private static function removeDeadEnds(aoMaze2d:Array, aoDeadEnds:Array, fPercentOfDeadEndsRemoved:Number):void		{			// setting sparseness to -1 means all 			//if ( nSparseness == -1 ) nSparseness = aoDeadEnds.length;						// cap sparseness value to the max # of dead ends the maze has to suppress errors			//if ( nSparseness > aoDeadEnds.length ) nSparseness = aoDeadEnds.length;						// shuffle the array of deadends to get a more realistic algorithm			ArrayUtils.shuffleArray(aoDeadEnds);						for (var i:int = 0; i < aoDeadEnds.length; i++)			{				if ( fPercentOfDeadEndsRemoved > MersenneTwister.nGenerateRandomFloatFromInstance(_oRandomNumberGenerator) )				{					var t:Tile = aoDeadEnds[i];					//trace( "****************** attempting deadend removal! tx: " + t.tx + " ty: " + t.ty)									// here we're checking to see where the tile is.					// if it's in a corner, we can't destroy the corner walls.					// if it's against the perimeter of the maze, we can't destroy the outer walls.					// if it's somewhere in the middle, any wall should be fair game.					if (t.tx == 0 && t.ty == 0)					{						// upper left corner						destroyRandomWall(aoMaze2d, t, [DIR_N, DIR_W])					} 					else if (t.tx == 0 && t.ty == aoMaze2d.length - 1)					{						// bottom left corner						destroyRandomWall(aoMaze2d, t, [DIR_S, DIR_W])					}					else if (t.tx == aoMaze2d[0].length - 1 && t.ty == 0)					{						// upper right corner						destroyRandomWall(aoMaze2d, t, [DIR_N, DIR_E])					}					else if (t.tx == aoMaze2d[0].length - 1 && t.ty == aoMaze2d.length - 1)					{						// bottom right corner						destroyRandomWall(aoMaze2d, t, [DIR_S, DIR_E])					}					else if (t.tx == 0)					{						// on left edge						destroyRandomWall(aoMaze2d, t, [DIR_W])					}					else if (t.tx == aoMaze2d[0].length - 1)					{						// on right edge						destroyRandomWall(aoMaze2d, t, [DIR_E])					}					else if (t.ty == 0)					{						// on top edge						destroyRandomWall(aoMaze2d, t, [DIR_N])					}					else if (t.ty == aoMaze2d.length - 1)					{						// on bottom edge						destroyRandomWall(aoMaze2d, t, [DIR_S])					}					else					{						// somewhere in middle of maze..not an exterior wall						destroyRandomWall(aoMaze2d, t, [])					}				} 				else				{					//trace( "****************** deadend removal failed @random chance!")				}			}		};				private static function destroyWalls(aoMaze2d:Array, fAdditionalWallsDestroyed:Number):void		{			//trace("MazeCreator::destroyWalls()");			for (var row:int = 0; row < aoMaze2d.length; row++)			{				for (var col:int = 0; col < aoMaze2d[0].length; col++)				{					var t:Tile = aoMaze2d[row][col];					var n:Tile;					var random:Number;										// attempt to destroy north wall					if (row != 0)					{						random = MersenneTwister.nGenerateRandomFloatFromInstance(_oRandomNumberGenerator);						if (fAdditionalWallsDestroyed > random) 						{							n = aoMaze2d[row - 1][col]							destroyWall(t, DIR_N, n);						}					}										// attempt to destroy east wall					if (col != aoMaze2d[row].length - 1)					{						random = MersenneTwister.nGenerateRandomFloatFromInstance(_oRandomNumberGenerator);						if (fAdditionalWallsDestroyed > random) 						{							n = aoMaze2d[row][col + 1]							destroyWall(t, DIR_E, n);						}					}										// attempt to destroy south wall					if (row != aoMaze2d.length - 1)					{						random = MersenneTwister.nGenerateRandomFloatFromInstance(_oRandomNumberGenerator);						if (fAdditionalWallsDestroyed > random) 						{							n = aoMaze2d[row + 1][col]							destroyWall(t, DIR_S, n);						}					}										// attempt to destroy west wall					if (col != 0)					{						random = MersenneTwister.nGenerateRandomFloatFromInstance(_oRandomNumberGenerator);						if (fAdditionalWallsDestroyed > random) 						{							n = aoMaze2d[row][col - 1]							destroyWall(t, DIR_W, n);						}					}				}			}		};				private static function destroyWall(tile:Tile, nDirection:int, neighbor:Tile):void		{			switch (nDirection)			{				case DIR_N :					tile.bWall_Up = false					neighbor.bWall_Down = false;				break;				case DIR_S :					tile.bWall_Down = false;					neighbor.bWall_Up = false;				break;				case DIR_E :					tile.bWall_Right = false;					neighbor.bWall_Left = false;				break;				case DIR_W :					tile.bWall_Left = false;					neighbor.bWall_Right = false;				break;			}		};				private static function destroyRandomWall(aoMaze2d:Array, targetTile:Tile, aoExceptions:Array):void		{			//trace("\n" + MazeCreator::destroyRandomWall() tx: " + targetTile.tx + " ty: " + targetTile.ty + " aoExceptions: " + aoExceptions);						var bDirectionFound:Boolean = false;			var nDirection:int;			var oNeighbor:Tile;						var anPossibleDirections:Array = [DIR_N, DIR_S, DIR_E, DIR_W];			var anDirections:Array = new Array();			var bValidDirection:Boolean = false;						// build array of directions that are valid.			for (var i:int = 0; i < anPossibleDirections.length; i++)			{				bValidDirection = true;				for (var j:int = 0; j < aoExceptions.length; j++)				{					if ( aoExceptions[j] == anPossibleDirections[i]){						bValidDirection = false;					}				}				if ( bValidDirection ) anDirections.push(anPossibleDirections[i]);			}						anDirections = ArrayUtils.shuffleArray(anDirections);						//trace(" * Exceptions removed. possible directions: " + anDirections);						while(!bDirectionFound && anDirections.length > 0)			{				// get the next random direction to check				nDirection = anDirections.shift();				//trace( " * testing direction: " + nDirection );								// check to see if that index is valid				bValidDirection = true;								// the random direction is not an exception direction.				// but we still need to check if the random direction has a wall there.				// if there isn't a wall, then we don't have anything to destroy, so we'll start over.				if ( bValidDirection )				{					switch(nDirection)					{						case DIR_N:							if (!targetTile.bWall_Up) {								bValidDirection = false;								//trace("   * direction " + nDirection + " invalid - no wall!..remaining: " + anDirections )							}							else							{								//trace("   * north direction " + nDirection + " valid!")							}						break;						case DIR_S:							if (!targetTile.bWall_Down) {								bValidDirection = false;								//trace("   * direction " + nDirection + " invalid - no wall!..remaining: " + anDirections )							}							else							{								//trace("   * south direction " + nDirection + " valid!")							}						break;						case DIR_E:							if (!targetTile.bWall_Right) {								bValidDirection = false;								///trace("   * direction " + nDirection + " invalid - no wall!..remaining: " + anDirections )							}							else							{								//trace("   * east direction " + nDirection + " valid!")							}						break;						case DIR_W:							if (!targetTile.bWall_Left) {								bValidDirection = false;								//trace("   * direction " + nDirection + " invalid - no wall!..remaining: " + anDirections )							}							else							{								//trace("   * west direction " + nDirection + " valid!")							}						break;					}				}								// we've passed all the trials a tile must go through.				if ( bValidDirection ) bDirectionFound = true;				//trace("   * bDirectionFound: " + bDirectionFound );			}						// we should have a valid direction here.			if ( bDirectionFound )			{				//trace(" * breaking wall at " + nDirection);				// destroy the wall in the target tile, and destroy the wall in the target tile's neighbor				switch (nDirection)				{					case DIR_N :						targetTile.bWall_Up = false;						oNeighbor = aoMaze2d[targetTile.ty - 1][targetTile.tx];						oNeighbor.bWall_Down = false;					break;					case DIR_S :						targetTile.bWall_Down = false;						oNeighbor = aoMaze2d[targetTile.ty + 1][targetTile.tx];						oNeighbor.bWall_Up = false;					break;					case DIR_E :						targetTile.bWall_Right = false;						oNeighbor = aoMaze2d[targetTile.ty][targetTile.tx + 1];						oNeighbor.bWall_Left = false;					break;					case DIR_W :						targetTile.bWall_Left = false;						oNeighbor = aoMaze2d[targetTile.ty][targetTile.tx - 1];						oNeighbor.bWall_Right = false;					break;				}								targetTile.bWallDestroyed = true;			}			else			{				//trace(" * Test_Advanced::destroyRandomWall() ERROR: could not find a valid wall to break!");			}		};	}}