/////////////////////////////////////////////////////	RoomCreatorTest//	CREATED: 2009-08-11//	BY: CHASE DE LANGUILLETTE - chase.delanguillette@gmail.com////	CLASS RESPONSIBILITES://	* calling aoGenerateMazeWithRooms with the appropriate parameters will generate a maze populated with rooms.//////////////////////////////////////////////////////package com.chasedelanguillette.roguish.maps.building{	//============================================	//	CUSTOM IMPORTS	//============================================	import com.chasedelanguillette.utils.ArrayUtils;	import com.chasedelanguillette.utils.MersenneTwister;	import com.chasedelanguillette.roguish.maps.sections.Tile;	import com.chasedelanguillette.roguish.maps.sections.Room;	import com.chasedelanguillette.roguish.maps.FloorMap;	import com.chasedelanguillette.roguish.maps.Minimap;	import com.chasedelanguillette.roguish.editor.roomEditor.MapData;// Thu Sep 10 19:43:44 CDT 2009 CMD TODO: move MapData class to a more sensible location	import com.chasedelanguillette.roguish.defines.TileDefines;			//============================================	//	STANDARD IMPORTS	//============================================	import flash.utils.getTimer;	import flash.geom.Rectangle;			public class RoomCreator	{				private static var _oRandomNumberGenerator:MersenneTwister;				public static const DIR_N:int 						= 1;         		public static const DIR_S:int 						= 2;         		public static const DIR_E:int 						= 3;         		public static const DIR_W:int 						= 4;				//============================================		//	PUBLIC METHODS		//============================================						public static function cleanUp():void		{			if ( _oRandomNumberGenerator != null )			{				_oRandomNumberGenerator = null;			}		}				public static function vCreateGreatHall(oFloorMap:FloorMap):void		{			var i:int;			var j:int;						// create a big, empty room			for (i = 0; i < oFloorMap.tiles.length; i++)			{				for (j = 0; j < oFloorMap.tiles[0].length; j++)				{					if ( i == 0 || j == 0 || i == oFloorMap.tiles.length - 1 || j == oFloorMap.tiles[0].length - 1 )					{						// force the tile to be a wall.						oFloorMap.tiles[i][j] = 3;// Mon Sep  7 14:10:15 CDT 2009 CMD TODO: switch 3 to constant					}					else					{						oFloorMap.tiles[i][j] = 1;// Mon Sep  7 14:10:33 CDT 2009 CMD TODO: switch 1 to constant					}				}			}						// clear existing roomdata!			if (oFloorMap.rooms != null )			{				for (i = 0; i < oFloorMap.rooms.length; i++)				{					for (j = 0; j < oFloorMap.rooms[i].length; j++)					{						oFloorMap.rooms[i][j].cleanUp();						oFloorMap.rooms[i][j] = null;					}					oFloorMap.rooms[i] = null;				}			}			oFloorMap.rooms = null;						// wipe the minimap & make it just one, empty room			oFloorMap.minimap.newMap(1, 1);						// define a new room region.			var roomRegion:Room = new Room(1, 1, oFloorMap.tiles[0].length - 2, oFloorMap.tiles.length - 2)			var tiles:Array = oFloorMap.tiles;			var rooms:Array = [roomRegion];			var exits:Array = new Array();						oFloorMap.rooms = [[new MapData(tiles, rooms, exits)]];		}				public static function oGenerateFloorMap(oNumberGenerator:MersenneTwister, oMinimap:Minimap, oRoomSet:Array, nRoomWidth:int = 10, nRoomHeight:int = 10, nDungeonType:int = MapData.MAP_TYPE_DUNGEON):FloorMap		{			_oRandomNumberGenerator = oNumberGenerator;						// filter the room set down to just those of the preferred type.			var filteredRoomSet:Array = new Array();			for (var roomIndex:int = 0; roomIndex < oRoomSet.length; roomIndex++)			{				if ((oRoomSet[roomIndex].mapTypeMask & nDungeonType) > 0)				{					filteredRoomSet.push(oRoomSet[roomIndex]);				}			}						//trace("RoomCreator::oGenerateFloorMap()");			var startTime:int;			var endTime:int;			startTime = getTimer();						// first thing's first - create the blank map!			var mw:int = oMinimap.aoMapLayout[0].length;			var mh:int = oMinimap.aoMapLayout.length;			mw *= nRoomWidth;			mh *= nRoomHeight;						var m:Array = ArrayUtils.newArray2D(mw, mh, 0);			var aoRoomData:Array = new Array();						// now that we've got the map stats, let's figure out 			for (var i:int = 0; i < oMinimap.aoMapLayout.length; i++)			{				aoRoomData[i] = new Array();								for (var j:int = 0; j < oMinimap.aoMapLayout[0].length; j++)				{					var oRoom:Tile = oMinimap.aoMapLayout[i][j];															// get the room position					var nRoomX:int = j * nRoomWidth;					var nRoomY:int = i * nRoomHeight;										// choose a room to place randomly					var nRandomRoomIndex:int = Math.floor(MersenneTwister.nGenerateRandomFloatFromInstance(_oRandomNumberGenerator) * filteredRoomSet.length);					var oRoomData:MapData = filteredRoomSet[nRandomRoomIndex];										// copy the transformed room data to a different array.					aoRoomData[i][j] = MapData.oCopyMapData(oRoomData);					var oRoomDataCopy:MapData = aoRoomData[i][j];										// randomly transform the room we're going to place					// Sat Aug 15 19:18:39 CDT 2009 CMD TODO: THIS MIGHT CAUSE A MEMORY LEAK..BE CAREFUL!!					oRoomDataCopy.randomlyTransformRoom(_oRandomNumberGenerator);										ArrayUtils.pasteArray2D(oRoomDataCopy.tiles, m, nRoomX, nRoomY);										// now figure out if we need to turn the exits off.					if ( oRoom.bWall_Up ) 		turnOffExit(m, oRoomDataCopy, DIR_N, nRoomX, nRoomY);					if ( oRoom.bWall_Down ) 	turnOffExit(m, oRoomDataCopy, DIR_S, nRoomX, nRoomY);					if ( oRoom.bWall_Right ) 	turnOffExit(m, oRoomDataCopy, DIR_E, nRoomX, nRoomY);					if ( oRoom.bWall_Left ) 	turnOffExit(m, oRoomDataCopy, DIR_W, nRoomX, nRoomY);				}			}									// let's double check			//ArrayUtils.traceArray2D(m);						// now do something with the room layout..lay the rooms!			//var m:Array = newMazeWithRooms(oMinimap.aoMapLayout, nRoomWidth, nRoomHeight);			//m = vConvertComplexTilesToSimpleTiles(m); // this is a great place to intercept the map and convert it to whatever you want!						endTime = getTimer();			trace("RoomCreatorTest::oGenerateFloorMap() -> room layout created in " + (endTime - startTime) + " ms.");			var oFloorMap:FloorMap = new FloorMap(m, aoRoomData, oMinimap);			return oFloorMap;		};				private static function turnOffExit(map:Array, room:MapData, nDirection:int, roomX:int, roomY:int):void		{			//trace("RoomCreator::turnOffExit() -> nDirection: " + nDirection + " roomX: " + roomX + " roomY: " + roomY);			var region:Room;			switch(nDirection)			{				case DIR_N:					//trace("RoomCreator::turnOffExit() -> north exit region found!");					region = MapData.getExitNorth(room);				break;				case DIR_S:					//trace("RoomCreator::turnOffExit() -> south exit region found!");					region = MapData.getExitSouth(room);				break;				case DIR_E:					//trace("RoomCreator::turnOffExit() -> east exit region found!");					region = MapData.getExitEast(room);				break;				case DIR_W:					//trace("RoomCreator::turnOffExit() -> west exit region found!");					region = MapData.getExitWest(room);				break;				default :					//trace("RoomCreator::turnOffExit() -> NO REGION FOUND!!!!");					region = new Room(0,0,0,0);				break;			}						if ( region )			{								for (var i:int = 0; i < region.height; i++)				{					for (var j:int = 0; j < region.width; j++)					{						var tx:int = region.x + roomX + j;						var ty:int = region.y + roomY + i;						map[ty][tx] = TileDefines.TILE_WALL;					}				}			}								};		}}