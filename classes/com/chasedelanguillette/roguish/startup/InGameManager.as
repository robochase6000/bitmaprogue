/////////////////////////////////////////////////////	InGameManager//	CREATED: 2009-09-21.//	BY: CHASE DE LANGUILLETTE - chase.delanguillette@gmail.com////	CLASS RESPONSIBILITES://////////////////////////////////////////////////////package com.chasedelanguillette.roguish.startup{	//============================================	//	CUSTOM IMPORTS	//============================================		import com.chasedelanguillette.roguish.editor.roomEditor.MapData;	// SYSTEM IMPORTS	import com.chasedelanguillette.roguish.startup.InitSystem;	import com.chasedelanguillette.roguish.InputConverter;			// COMMON DEFS	import com.chasedelanguillette.roguish.defines.MazeDefines;	import com.chasedelanguillette.roguish.defines.RenderDefines;	import com.chasedelanguillette.roguish.defines.Directions;			// RENDERING IMPORTS	import com.chasedelanguillette.roguish.rendering.BitmapRendererLite;	import com.chasedelanguillette.roguish.rendering.MinimapRenderer;	import com.chasedelanguillette.roguish.rendering.Camera;	import com.chasedelanguillette.roguish.rendering.animation.characters.CharacterAnimation;	// MAP IMPORTS	import com.chasedelanguillette.roguish.maps.building.DungeonMaker;	import com.chasedelanguillette.roguish.maps.loading.RoomListLoader;	import com.chasedelanguillette.roguish.maps.FloorMap;			// MISC GAME IMPORTS	// Tue Oct 20 08:58:05 CDT 2009 CMD TODO: gotta reorganize these!	import com.chasedelanguillette.roguish.Collisions;			// game.defines?	import com.chasedelanguillette.roguish.characters.Mobile;	// OUTDATED!!!!			// NEW STUFF	import com.chasedelanguillette.roguish.objects.physicalObjects.living.LivingObject;	import com.chasedelanguillette.roguish.objects.physicalObjects.PhysicalObject;	import com.chasedelanguillette.roguish.objects.properties.Action;	//import game.objects.intangibles.combat.AttackPatterns;	// UI IMPORTS	import com.chasedelanguillette.roguish.ui.inGame.HUD;			// COMMON LIBRARY IMPORTS	import com.chasedelanguillette.LerpMachine;	import com.chasedelanguillette.TileUtils;	import com.chasedelanguillette.NumberUtils;	import com.chasedelanguillette.geom.SimplePoint;	import com.chasedelanguillette.system.DebugConsole;	import com.chasedelanguillette.system.input.InputManager;		import com.chasedelanguillette.system.debug.DebugManager;	import com.chasedelanguillette.system.debug.ScreenPrint;			//============================================	//	NATIVE IMPORTS	//============================================	import flash.display.Stage;	import flash.display.Sprite;	import flash.display.Bitmap;	import flash.display.BitmapData;		import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.KeyboardEvent;	import flash.events.EventDispatcher;		import flash.geom.Rectangle;			public class InGameManager extends EventDispatcher	{		public static const EXIT_TYPE_VICTORY:int 			= 0;		public static const EXIT_TYPE_QUIT_NO_SAVE:int 		= 1;		public static const EXIT_TYPE_QUIT_AND_SAVE:int 	= 2;		public static const EXIT_TYPE_GAME_OVER:int 		= 3;		public static const EXIT_TYPE_PLAYER_DIED:int 		= 4;		public static const EXIT_TYPE_NEW_DUNGEON:int 		= 5;				private var _nExitType:int;		public var id:int = -1;				private var _oInitSystem:InitSystem = InitSystem.getInstance();						private var _oStage:Stage;		private var _bInitialized:Boolean = false;				private var _oFloorMap:FloorMap 					= null;		private var _oRoomListLoader:RoomListLoader;		private var _oDungeonMaker:DungeonMaker;						/// BITMAP RENDERING STUFF		private var _oCamera:Camera;		private var _oBitmapRenderer:BitmapRendererLite;		private var _bBitmapRenderingEnabled:Boolean 		= RenderDefines.BITMAP_RENDERING_ENABLED;						private var _bmdTileSet:TestTileSet 				= new TestTileSet(640, 640);		private var _bmdHeroSheet:Shiren					= new Shiren(640, 640);		private var _bmdSpriteSheet_BlackBlob:Blob_Black	= new Blob_Black(640, 640);		private var _bmdItemSheet:Items						= new Items(640, 640);								private var _bmpCanvas:Bitmap 						= null;		private var _bmpdMiniMap:BitmapData 				= null;		private var _bmpMiniMap:Bitmap 						= null;						/// MINIMAP!		private var _oMinimapRenderer:MinimapRenderer;		private var _oMinimapSprite:Sprite;						/// MISC.		private var _oHudContainer:Sprite;		private var _oGameContainer:Sprite;		private var _oMinimapContainer:Sprite;		private var _oDebugConsoleContainer:Sprite;				/// MOVEMENT STUFF		private var _oLerpX:LerpMachine = new LerpMachine();		private var _oLerpY:LerpMachine = new LerpMachine();		private var _bLerpX:Boolean = false;		private var _bLerpY:Boolean = false;						/// SYSTEM STUFF		private var _oDebugConsole:DebugConsole;						/// UI STUFF		private var _oHUD:HUD;		private var _oMouseCursor:MouseCursor;						/// INPUT MANAGER!		private var _oInputConverter:InputConverter;		private var _oInputManager:InputManager;				// current dungeon settings -- 		private var _nCurrentDungeonType:int = -1;// probably better to store this with FloorMap or something..								//============================================================================		//	SINGLETON STUFF - GRAB AN INSTANCE WITH InGameManager.getInstance()		//============================================================================		private static var instance:InGameManager;				/**		*	@constructor		*/		public function InGameManager(o:SingletonEnforcer):void		{			trace("InGameManager::InGameManager()");		};						/**		*			*/		public static function getInstance():InGameManager		{			if (instance==null)			{				instance = new InGameManager(new SingletonEnforcer());			}			return instance;		}								//============================================================================		//	public functions		//============================================================================						/**		*			*/		public function cleanup():void		{			trace("InGameManager::cleanup()");			_oStage = null;			// & whatever else		};						/**		*			*/		public function initialize(stageReference:Stage):void		{			if ( !_bInitialized )			{				_oStage = stageReference;				// conditionally skip the game!				if (_oInitSystem.bSkipGame)				{					trace("InGameManager::initialize() -> SKIPPING GAME");					dispatchEvent(new Event(Event.COMPLETE));				}				else				{					trace("InGameManager::initialize() -> INITIALIZING GAME");										// initialize game container!					_oGameContainer = new Sprite();					_oStage.addChild(_oGameContainer);					_oGameContainer.visible = false;										// intiailize minimap!					_oMinimapContainer = new Sprite();					_oStage.addChild(_oMinimapContainer);										// intiailize debug console!					if (_oInitSystem.bDebugEnabled)					{						_oDebugConsoleContainer = new Sprite();						_oStage.addChild(_oDebugConsoleContainer);						_oDebugConsole = new DebugConsole();						_oDebugConsoleContainer.addChild(_oDebugConsole);					}										// initialize hud!					if (_oInitSystem.bHudEnabled)					{						_oHudContainer = new Sprite();						_oStage.addChild(_oHudContainer);						_oHUD = new HUD();						_oHudContainer.addChild(_oHUD);					}										/// initialize Input!					_oStage.addEventListener( KeyboardEvent.KEY_DOWN, vHandle_this_KEY_DOWN );					_oStage.addEventListener( KeyboardEvent.KEY_UP, vHandle_this_KEY_UP );					_oStage.focus = _oGameContainer;					_oInputManager = _oInitSystem.oInputManager;					_oInputConverter = InputConverter.getInstance();					_oInputConverter.setInputManager(_oInputManager);															// kick off room loading to get things started!					_oRoomListLoader = new RoomListLoader("xml/maps/test/RoomList.xml");					_oRoomListLoader.addEventListener( Event.COMPLETE, vHandle_oRoomListLoader_COMPLETE );				}								DebugManager.init(_oStage);			}		};						/**		*	Fired when the _oRoomListLoader has finished loading the rooms we are going to use for this map!		*/		private function vHandle_oRoomListLoader_COMPLETE(evt:Event):void		{			trace("InGameManager::vHandle_oRoomListLoader_COMPLETE()");			_oRoomListLoader.removeEventListener( Event.COMPLETE, vHandle_oRoomListLoader_COMPLETE );			vMakeNewMap();		}				private function vDestroyOldMap():void		{			while(_oGameContainer.numChildren > 0)			{				_oGameContainer.removeChildAt(0);			}									// remove minimap			_oStage.removeChild(_oMinimapContainer);			_oMinimapContainer = new Sprite();			_oStage.addChild(_oMinimapContainer);						_oStage.removeEventListener(Event.ENTER_FRAME, frameUpdate);						_oCurrentMonster = null;		}				private function vMakeNewMap():void		{							vDestroyOldMap();						// intialize dungeon  maker!			// DungeonMaker(mapSeed:int = 200, monsterSeed:int = 200, itemSeed:int = 200):void			_oDungeonMaker = new DungeonMaker(Math.floor(Math.random() * 0xffffff), 213, 213);//(213, 213, 213);						/*			// here for reference cos it takes a lot of params!			public function buildMap(	aoRoomSet:Array, 										nMazeWidthInRooms:int = 3, nMazeHeightInRooms:int = 3, 										fDeadEndsRemoved:Number = 0.0, fSparseness:Number = 0.0, fAdditionalWallsDestroyed:Number = 0.25,										nRoomWidthInTiles:int = 27, nRoomHeightInTiles:int = 27,										fGreatHallChance:Number = 0.0, fMonsterHouseChance:Number = 0.0,										nMonsterCountMin:int = 0, nMonsterCountMax:int = 0,										nItemCountMin:int = 0, nItemCountMax:int = 0										):void			*/						var roomList:Array = _oRoomListLoader.aoMapData;			var nMazeWidthInRooms:int = MazeDefines.MAZE_WIDTH_IN_ROOMS;			var nMazeHeightInRooms:int = MazeDefines.MAZE_HEIGHT_IN_ROOMS;			var fDeadEndsRemoved:Number = MazeDefines.MAZE_DEAD_ENDS_REMOVED;			var fMazeSparseness:Number = MazeDefines.MAZE_SPARSENESS;			var fPerecentOfAdditionalWallsDestroyed:Number = MazeDefines.MAZE_ADDITIONAL_WALLS_DESTROYED;			var nRoomWidthInTiles:int = MazeDefines.ROOM_WIDTH_IN_TILES;			var nRoomHeightInTiles:int = MazeDefines.ROOM_HEIGHT_IN_TILES;			var fGreatHallChance:Number = 0.0;			var fMonsterHallChance:Number = 0.0;			var nMonsterCount_Min:int = MazeDefines.MIN_MONSTERS;			var nMonsterCount_Max:int = MazeDefines.MAX_MONSTERS;			var nItemCount_Min:int = MazeDefines.MIN_ITEMS;			var nItemCount_Max:int = MazeDefines.MAX_ITEMS;												_oDungeonMaker.buildMap(	roomList,										nMazeWidthInRooms, nMazeHeightInRooms,										fDeadEndsRemoved, fMazeSparseness, fPerecentOfAdditionalWallsDestroyed,										nRoomWidthInTiles, nRoomHeightInTiles,										fGreatHallChance, fMonsterHallChance,										nMonsterCount_Min, nMonsterCount_Max,										nItemCount_Max, nItemCount_Max,										_nCurrentDungeonType										)													_oDungeonMaker.addEventListener( Event.COMPLETE, vHandle_oDungeonMaker_COMPLETE );		};				private var _bmdTiles:BitmapData = new BitmapData(InitSystem.nStageWidth + 1, InitSystem.nStageHeight + 1, true, 0x00000000);		private var _bmdSprites:BitmapData = new BitmapData(InitSystem.nStageWidth + 1, InitSystem.nStageHeight + 1, true, 0x00000000);		private var _bmdItems:BitmapData = new BitmapData(InitSystem.nStageWidth + 1, InitSystem.nStageHeight + 1, true, 0x00000000);		private var _bmdVFX:BitmapData = new BitmapData(InitSystem.nStageWidth + 1, InitSystem.nStageHeight + 1, true, 0x00000000);				private var _bmpSprites:Bitmap = new Bitmap(_bmdSprites);		private var _bmpItems:Bitmap = new Bitmap(_bmdItems);		private var _bmpVFX:Bitmap = new Bitmap(_bmdVFX);				private var _rectRenderLayer:Rectangle = new Rectangle();		/**		*	Fired when the dungeom maker has finished making its map.			*/		private function vHandle_oDungeonMaker_COMPLETE(evt:Event)		{			trace("InGameManager::vHandle_oDungeonMaker_COMPLETE()");						_oDungeonMaker.removeEventListener( Event.COMPLETE, vHandle_oDungeonMaker_COMPLETE );						// get the floor map from the dungeon maker!			_oFloorMap = _oDungeonMaker.oFloorMap;						// get the hero from the floor map			_oHero = _oFloorMap.oHero;						_bmdTiles = new BitmapData(InitSystem.nStageWidth + 1, InitSystem.nStageHeight + 1, true, 0x00000000);			_bmdSprites = new BitmapData(InitSystem.nStageWidth + 1, InitSystem.nStageHeight + 1, true, 0x00000000);			_bmdItems = new BitmapData(InitSystem.nStageWidth + 1, InitSystem.nStageHeight + 1, true, 0x00000000);			_bmdVFX = new BitmapData(InitSystem.nStageWidth + 1, InitSystem.nStageHeight + 1, true, 0x00000000);						_bmpSprites = new Bitmap(_bmdSprites);			_bmpItems = new Bitmap(_bmdItems);			_bmpVFX = new Bitmap(_bmdVFX);						// initialize bitmap renderer!			// new BitmapRenderer(tileArray, tileSet, viewport width, viewport height, tile width, tile height)			_oBitmapRenderer = new BitmapRendererLite(	_oFloorMap.tiles, 													_bmdTileSet as BitmapData, 													InitSystem.nRenderWidth, 													InitSystem.nRenderHeight, 													RenderDefines.TILE_WIDTH, 													RenderDefines.TILE_HEIGHT,													_bmdTiles													);																// add the bitmap renderer's canvas to the stage.			_bmpCanvas = new Bitmap(_oBitmapRenderer.bmdCanvas);			_bmpCanvas.scaleX = _bmpCanvas.scaleY = InitSystem.nRenderScale;						_rectRenderLayer.width = _bmdTiles.width;			_rectRenderLayer.height = _bmdTiles.height;									// add the layers.			_oGameContainer.addChild(_bmpCanvas);			_oGameContainer.addChild(_bmpItems);			_oGameContainer.addChild(_bmpSprites);			_oGameContainer.addChild(_bmpVFX);						_bmpSprites.scaleX = _bmpSprites.scaleY =_bmpCanvas.scaleX;			_bmpItems.scaleX = _bmpItems.scaleY =_bmpCanvas.scaleX;			_bmpVFX.scaleX = _bmpVFX.scaleY =_bmpCanvas.scaleX;				_oStage.addEventListener( MouseEvent.CLICK, vHandle_stage_CLICK );			_oStage.addEventListener( MouseEvent.MOUSE_MOVE, vHandle_stage_MOUSE_MOVE );						// set up the camera for the bitmap renderer.			_oCamera = new Camera(	_oBitmapRenderer.nMapWidthInPixels, 									_oBitmapRenderer.nMapHeightInPixels, 									_oBitmapRenderer.nCanvasWidth, 									_oBitmapRenderer.nCanvasHeight									);												// 			_oBitmapRenderer.viewUpdate(_oCamera.nViewOffsetX,_oCamera.nViewOffsetY);			_oBitmapRenderer.drawTiles(_oFloorMap.tiles, _bmdTileSet as BitmapData);			// assign lerp machines to bitmap renderer.  this is pretty much a shortcut.			_oBitmapRenderer.oLerpX = _oLerpX;			_oBitmapRenderer.oLerpY = _oLerpY;									// INIT MINIMAP LAYERS!			// the minimap is broken into layers.  Here is what I have so far:			// * Tiles (_oMinimapRenderer.bmpMiniMap)			// * Sprites (_oMinimapRenderer.bmpSprites)			_oMinimapRenderer = new MinimapRenderer(_oFloorMap);			var bmpMiniMap:Bitmap = _oMinimapRenderer.bmpMiniMap;			var bmpMiniMapSprites:Bitmap = _oMinimapRenderer.bmpSprites;			addMinimapLayerToStage(bmpMiniMap);			addMinimapLayerToStage(bmpMiniMapSprites);						_oMinimapRenderer.vUpdate();						_oMouseCursor = new MouseCursor();			_oMouseCursor.scaleX = _oMouseCursor.scaleY = InitSystem.nRenderScale;			if (!CONFIG::MINIMAP_DEMO)			{				if (_oHudContainer) _oHudContainer.addChild(_oMouseCursor)			}						// start up the main loop!			_oStage.addEventListener(Event.ENTER_FRAME, frameUpdate);		}						/**		*			*/		private function vHandle_stage_CLICK(evt:MouseEvent):void		{			trace("InGameManager::vHandle_oGameContainer_CLICK() x: " + _oStage.mouseX + " y: " + _oStage.mouseY);			var mx:int = _oStage.mouseX;			var my:int = _oStage.mouseY;						var tx:int = int(mx / RenderDefines.TILE_WIDTH);			var ty:int = int(my / RenderDefines.TILE_HEIGHT);						mx = tx * RenderDefines.TILE_WIDTH;			my = ty * RenderDefines.TILE_HEIGHT;						_oMouseCursor.x = mx;			_oMouseCursor.y = my;						tx += _oBitmapRenderer.nStartTileX;			ty += _oBitmapRenderer.nStartTileY;						if (!CONFIG::MINIMAP_DEMO)			{				_oFloorMap.addMonster({tx:tx, ty:ty, type:Mobile.MONSTER})			}						trace("InGameManager::vHandle_oGameContainer_CLICK()", "tx: ", tx, "ty: ", ty)		}						/**		*			*/				private function vHandle_stage_MOUSE_MOVE(evt:MouseEvent):void		{			var tw:int = RenderDefines.TILE_WIDTH * InitSystem.nRenderScale;			var th:int = RenderDefines.TILE_HEIGHT * InitSystem.nRenderScale;						var mx:int = _oStage.mouseX;			var my:int = _oStage.mouseY;						var tx:int = int(mx / tw);			var ty:int = int(my / th);						mx = tx * tw;			my = ty * th;						_oMouseCursor.x = mx;			_oMouseCursor.y = my;						tx += _oBitmapRenderer.nStartTileX;			ty += _oBitmapRenderer.nStartTileY;									_oMouseCursor.dt_label.text = tx + ", " + ty;		}						/**		*			*/		private function oGetTilePositionAtScreenCoordinates(mx:int, my:int):SimplePoint		{			var tx:int = int(mx / RenderDefines.TILE_WIDTH);			var ty:int = int(my / RenderDefines.TILE_HEIGHT);						tx += _oBitmapRenderer.nStartTileX;			ty += _oBitmapRenderer.nStartTileY;						return new SimplePoint(tx, ty);		}						/**		*	Adds a layer of the minimap to the stage.		*			*	<p>Layers of the minimap might include a tile layer and sprite layer, for example.</p>		*/		public function addMinimapLayerToStage(bmp:Bitmap):void		{			_oMinimapContainer.addChild(bmp);			bmp.x = (InitSystem.nStageWidth - bmp.width) / 2;			bmp.y = (InitSystem.nStageHeight - bmp.height) / 2;		};						/**		*	Allows you to figure out how the user has left the game.		*			*	<p>For example, Qutting, Losing, etc.		*/		public function get nExitType():int		{			return _nExitType;		};						//============================================================================		//	MAIN UPDATE FUNCTIONS!		//============================================================================				private var _oCurrentMonster:LivingObject;		private var _oHero:Object;				// MOVEMENT VARS		private var _nMove:int = 0;		private var _oAction:Action = Action.getInstance();						private var _framesPerTurn:int = 6;		private var _nMonsterIndex:int = 0;				private var _aoMonstersReady:Array = new Array();		private var _nEnergyMax:int = 100;						/**		*	InGamManager's onEnterFrame loop.		*/		public function frameUpdate(evt:Event):void		{			//trace("InGameManager::frameUpdate()");			updateMonster();			render();						ScreenPrint.show("CURRENT DUNGEON: " + MapData.getMapTypeName(_nCurrentDungeonType) + ". " + MapData.getMapTypeDescription(_nCurrentDungeonType));			for (var i:int = 0; i < MapData.MAP_TYPES.length; i++)			{				ScreenPrint.show( "press " + (i+1) + " for random " + MapData.getMapTypeName(MapData.MAP_TYPES[i]) + " map" );			}						DebugManager.update();		};						/**		*	Updates world.  Gives the world a tick if needed.		*/		public function updateWorld():void		{			for ( var i:int = 0; i < _oFloorMap.monsters.length; i++ )			{				var m:LivingObject = _oFloorMap.monsters[i] as LivingObject;				m.oStats.energy += m.oStats.energyPerTurn;				if ( m.oStats.energy >= _nEnergyMax)				{					m.oStats.energy = m.oStats.energyMax;					_aoMonstersReady.push(m);				}								if ( m == _oHero.oPhysicalObject )				{					trace("InGameManager::updateWorld() -> update hero energy");					if (_oHudContainer) _oHUD.updateEnergyMeter(_oHero.oPhysicalObject.oStats.energy / 100);				}			}		};				/**		*	Frame update.  Goes through the rigamorole of figuring out what to each frame.		*			*	<p>The user isn't allowed input while monsters are moving..it's just the way it is.  Might let them pause, but that's it.</p>		*/		function updateMonster():Boolean		{			//trace("InGameManager::update()");						// see if we're still processing a monster			if ( _oCurrentMonster == null )			{				var bNextMonsterRequiresRendering:Boolean = false;				while(!bNextMonsterRequiresRendering)				{					// we're not processing a monster; get the next one off the list.					_oCurrentMonster = getNextMonster();										// Fri Oct  9 12:50:53 CDT 2009 CMD TODO: there's a couple frames at the beginning where this block is running, but the monsters haven't been placed yet.					// we should get rid of this check and fix THAT problem, not hack it here.					//if (_oCurrentMonster == null) return false;															// make sure we have a valid monster!					if ( _oCurrentMonster == null ) 					{						trace("InGameManager::update() -> WARNING :: could not find a monster to update!");												return false;					}										_oAction.reset();										// check whether we're dealing with the hero or a monster					if ( _oHero.oPhysicalObject != _oCurrentMonster )					{						// we've got to figure out what to do with this new monster.						figureOutMove(_oCurrentMonster);												// if the monster has been assigned to a lerp machine, then it requires rendering and we should break the while loop.						if ( _oLerpX.target == _oCurrentMonster || _oLerpY.target == _oCurrentMonster ) 						{							bNextMonsterRequiresRendering = true;						}					}					else					{						// we're dealing with a hero.						// the hero requires rendering, so let's break out of our loop!						bNextMonsterRequiresRendering = true;						_oHero.oPhysicalObject.bMoveMade = false;					}				}			}						if ( _oHero.oPhysicalObject == _oCurrentMonster && !_oHero.oPhysicalObject.bMoveMade)			{				// update the hero.				handlePlayersTurn(0);			}							updateLerps();			return true;		}						/**		*	Gets the next Monster in the priority Queue.		*/		public function getNextMonster():LivingObject		{			//trace("InGameManager::getNextMonster()");						var m:LivingObject;			if ( _aoMonstersReady.length > 0 )			{				m = _aoMonstersReady.shift();			}			else			{				if ( _oFloorMap.monsters.length <= 0 ) return null;								while(_aoMonstersReady.length <= 0) 				{					updateWorld();				}								if (_oHero.oPhysicalObject) _oHero.oPhysicalObject.bMoveMade = false;				m = _aoMonstersReady.shift() as LivingObject;			}						return m;		};						/**		*	Checks for user input.  If a valid move was registered from users input, the player makes a move.		*/		public function handlePlayersTurn(nPlayerId:int):void		{			//trace("InGameManager::handlePlayersTurn()");				checkInput();		};				/**		*	Has the monster's AI figure out what to do for them this turn.		*			*	<p>Insert AI here lol.</p>		*/		public function figureOutMove(m:LivingObject):void		{			//trace("InGameManager::figureOutMove()");						// insert AI here!						// start with a mask containing every possible direction this monster can move.			var nDirectionsRemaining:int = Directions.M_OMNI_DIRECTIONAL;						// 50% chance of changing directions			var nChangeDirection:Number = Math.random();			if ( nChangeDirection > 0.50 ) m.oDimensions.direction = NumberUtils.nGetRandomNumberRange(Math.random(), 0, 7);						var bValidMove:Boolean = false;			while(!bValidMove)			{								//var cx:int = NumberUtils.nGetRandomNumberRange(Math.random(), -1, 1);				//var cy:int = NumberUtils.nGetRandomNumberRange(Math.random(), -1, 1);				//var nCollisionType:int = moveCreature(m, cx, cy);								var mOffset:SimplePoint = Directions.oGetOffsetsFromDirection(m.oDimensions.direction);			 	var nCollisionType:int = moveCreature(m, mOffset.x, mOffset.y);								switch (nCollisionType)				{					case Collisions.NONE :												bValidMove = true;					break;					default :						// do something else?						nDirectionsRemaining = Directions.nRemoveDirectionFromMask(m.oDimensions.direction, nDirectionsRemaining);						m.oDimensions.direction = Directions.nGetNewDirection_RotateClockwise(m.oDimensions.direction, 45);					break;				}								if (nDirectionsRemaining == 0)				{					bValidMove = true;// shouldn't be though				}			}						endMove(m, m.oStats.energy);		};						/**		*	One place to handle the end of a monster's turn.		*/		private function endMove(m:LivingObject, nEnergyCost:int):void		{			m.oStats.energy -= nEnergyCost;						/*			if ( m.bTrackMoves )			{				m.addMove();							}			*/		}						/**		*	Checks for user input and deals with it accordingly.		*			*	<p>This is achieved by updating the InputConverter class.		*	The InputConverter class serves as a wrapper for the InputManager class - 		*	everytime the InputConverter instance is updated, it polls the InputManager to figure out which keys are pressed.		*	It then matches those key presses to in-game actions, and then returns a matching in-game action.</p>		*			*	<p>Wrapping the InputManager like this give me a lot of control over allowing game actions to be remapped to different keys.</p>		*/		private function checkInput():void		{						var nAction:int = _oInputConverter.update();			switch(nAction)			{				// minimap demo controls				case InputConverter.ACTION_GENERATE_DUNGEON:					if (CONFIG::MINIMAP_DEMO)					{						_nCurrentDungeonType = MapData.MAP_TYPE_DUNGEON;						vMakeNewMap();					}				break;				case InputConverter.ACTION_GENERATE_STREETS:					if (CONFIG::MINIMAP_DEMO)					{						_nCurrentDungeonType = MapData.MAP_TYPE_STREETS						vMakeNewMap();					}				break;				case InputConverter.ACTION_GENERATE_CAVES:					if (CONFIG::MINIMAP_DEMO)					{						_nCurrentDungeonType = MapData.MAP_TYPE_CAVES;						vMakeNewMap();					}				break;				case InputConverter.ACTION_GENERATE_MYSTERY_DUNGEON:					if (CONFIG::MINIMAP_DEMO)					{						_nCurrentDungeonType = MapData.MAP_TYPE_MYSTERY_DUNGEON;						vMakeNewMap();					}				break;				case InputConverter.ACTION_GENERATE_ALL:					if (CONFIG::MINIMAP_DEMO)					{						_nCurrentDungeonType = MapData.MAP_TYPE_ALL;						vMakeNewMap();					}				break;								case InputConverter.ACTION_GENERATE_NEXT_FLOOR:					if (CONFIG::MINIMAP_DEMO)					{						_nCurrentDungeonType = MapData.MAP_TYPES[Math.floor(Math.random() * MapData.MAP_TYPES.length)];						vMakeNewMap();					}				break;								case InputConverter.ACTION_NORTH_WEST:					handleHeroMove(-1, -1)				break;				case InputConverter.ACTION_NORTH:					handleHeroMove(0, -1)				break;				case InputConverter.ACTION_NORTH_EAST:					handleHeroMove(1, -1)				break;				case InputConverter.ACTION_WEST:					handleHeroMove(-1, 0)				break;				case InputConverter.ACTION_EAST:					handleHeroMove(1, 0)				break;				case InputConverter.ACTION_SOUTH_WEST:					handleHeroMove(-1, 1)				break;				case InputConverter.ACTION_SOUTH:					handleHeroMove(0, 1)				break;				case InputConverter.ACTION_SOUTH_EAST:					handleHeroMove(1, 1)				break;				case InputConverter.ACTION_WAIT:					trace("InGameManager::checkInput() -> ACTION_WAIT!");					wait(_oHero.oPhysicalObject);					_oHero.oPhysicalObject.bMoveMade = true;					_oLerpX.target = null;					_oLerpY.target = null;					_oCurrentMonster = null;					endMove(_oHero.oPhysicalObject, 50);					_oHUD.updateEnergyMeter(_oHero.oPhysicalObject.oStats.energy / 100)				break;				case InputConverter.ACTION_TOGGLE_MAP:					trace("InGameManager::checkInput() -> ACTION_TOGGLE_MAP!");					vToggleMinimap();				break;				case InputConverter.ACTION_TOGGLE_GAME_VIEW:					vToggleGameView();				break;				case InputConverter.ACTION_INVENTORY:					trace("InGameManager::checkInput() -> ACTION_INVENTORY!");				break;				case InputConverter.ACTION_PICK_UP:					trace("InGameManager::checkInput() -> ACTION_PICK_UP!");				break;				case InputConverter.ACTION_ATTACK:					trace("InGameManager::checkInput() -> ACTION_ATTACK!");					vAttack(_oHero.oPhysicalObject);				break;				case InputConverter.ACTION_MENU:					trace("InGameManager::checkInput() -> ACTION_MENU!");				break;				case InputConverter.ACTION_FIRE:					trace("InGameManager::checkInput() -> ACTION_FIRE!");				break;				case InputConverter.ACTION_READ_SCROLL:					trace("InGameManager::checkInput() -> ACTION_READ_SCROLL!");					break;				case InputConverter.ACTION_EAT:					trace("InGameManager::checkInput() -> ACTION_EAT!");				break;				case InputConverter.ACTION_USE_STAVE:					trace("InGameManager::checkInput() -> ACTION_USE_STAVE!");				break;				case InputConverter.ACTION_SWITCH_WEAPONS:					trace("InGameManager::checkInput() -> ACTION_SWITCH_WEAPONS!");				break;				default :					//trace("InGameManager::checkInput() -> INVALID KEY PRESS!");				break;			}		};				/**		*			*/		private function vAttack(attacker:LivingObject):void		{			var nAnimationLength:int = attacker.oRenderData.animation.getAnimationLength(CharacterAnimation.ATTACK);						// figure out which attack animation to play			attacker.oRenderData.animation.play(CharacterAnimation.ATTACK, attacker.oDimensions.direction);									// just do something stupid for now - attack in a line!			var origin:SimplePoint = new SimplePoint(attacker.oDimensions.x, attacker.oDimensions.y);						// attack pattern is a 2d array containing attack information, given the following structure:			// attackPattern[frameNumber] = arrayOfPoints			// basically every frame we look at the attackPattern array to determine where to attack.			//var attackPattern:Array = AttackPatterns.line(origin, attacker.oDimensions.direction, 5);						/*			// for every attacking square check for obstacles			for (var i:int = 0; i < attackPattern.length; i++)			{				SimplePoint.toString("attack square", attackPattern[i])				var p:SimplePoint = attackPattern[i];								// check point for "stuff"				var aoObjectList:Array = aoGetObjectListAtPoint(p.x, p.y);			}			*/						// initialize animation delay.			initLerp(_oLerpX, attacker, 0, 300, 0, nAnimationLength + 1, {type:0});						attacker.nCurrentAction = Action.ATTACK						attacker.bMoveMade = true;			endMove(attacker, attacker.oStats.energy);		};				/**		*	Gets a list of objects at whatever point on the map.		*/		private function aoGetObjectListAtPoint(x:int, y:int):Array		{			var aoObjectList:Array = new Array();						var oItem:PhysicalObject = _oFloorMap.getItemAt(x, y);			if (oItem) aoObjectList.push(oItem);						var oMonster:PhysicalObject = _oFloorMap.getMonsterAt(x, y);			if ( oMonster ) aoObjectList.push(oMonster);						return aoObjectList;		};						/**		*			*/		private function wait(c:LivingObject):void		{			trace("WAIT !!!!!");		}						/**		*	Handles a move.		*			*	<p>If the hero entered a move function, but the Shift key is held down, the creature will face the chosen		*	direction instead of moving there.</p>		*/		private function handleHeroMove(mx:int, my:int):void		{			if ( _oInputManager.key[InputManager.KEY_SHIFT] )			{				faceDirection(_oHero.oPhysicalObject, mx, my);			}			else			{				var nCollisionType:int = moveCreature(_oHero.oPhysicalObject, mx, my);				switch (nCollisionType)				{					case Collisions.NONE :							_oHero.oPhysicalObject.bMoveMade = true;							endMove(_oHero.oPhysicalObject, _oHero.oPhysicalObject.oStats.energy);							if (_oHudContainer) _oHUD.updateEnergyMeter(_oHero.oPhysicalObject.oStats.energy / 100)// Thu Nov 12 20:16:29 CST 2009 CMD TODO: why is this / 100???												break;					default :						// do something else?					break;				}			}		};						/**		*	Moves the hero based on offsets mx and my.		*			*	@param 	mx	x offset.		*	@param	my	y offset.		*			*	<p>This should be genericized to work for all creatures, not just the hero.</p>		*			*	<p>Returns an int indicating whether the creature collided with anything whilst moving.</p>		*			*/		private function moveCreature(creature:LivingObject, mx:int, my:int):int		{			// make sure at least one direction has a new move involved, otherwise we'll wind up doing unnecessary calculations.			if ( mx != 0 || my != 0 )			{				// figure out the target tile!				var tx:int = creature.oDimensions.x + mx;				var ty:int = creature.oDimensions.y + my;								// is the target tile a valid tile?				var t:int = _oFloorMap.tiles[ty][tx];												// check if tile is occupied				if (bTileOccupied(tx, ty)) return Collisions.OBJECT;								switch (t)				{					case 1:						// figure out if we need to lerp this guy or not.						// basically if he's on camera now or he will be after this move, we need to lerp him.						if (_oCamera.onCamera(tx * RenderDefines.TILE_WIDTH, ty * RenderDefines.TILE_HEIGHT) || _oCamera.onCamera(creature.oDimensions.x * RenderDefines.TILE_WIDTH, creature.oDimensions.y * RenderDefines.TILE_HEIGHT)) 						{							_oCurrentCreatureTarget.x = tx;							_oCurrentCreatureTarget.y = ty;							doLerpAnimation(creature, mx, my, _framesPerTurn, null);						}						else						{							_oLerpX.target = null;							_oLerpY.target = null;						}												_oFloorMap.handleMonsterMove(creature, tx, ty);						faceDirection(creature, mx, my);						creature.oDimensions.x = tx;						creature.oDimensions.y = ty;												creature.nCurrentAction = Action.MOVE												return Collisions.NONE;					break;				}			}						return Collisions.WALL;		};				private var _oCurrentCreatureTarget:SimplePoint = new SimplePoint(0,0);						/**		*	Makes a creature face a particular direction based on x and y offsets.		*/		private function faceDirection(m:LivingObject, movex:int, movey:int):void		{			var dir:int = Directions.nBuildDirectionMask(movex, movey);			dir = Directions.nGetEnumeratedDirectionFromMask(dir);			m.oDimensions.direction = dir;		};						/**		*	Returns whether a specific tile is occupied or not.		*/		private function bTileOccupied(tx:int, ty:int):Boolean		{			return _oFloorMap.bTileContainsMonster(tx, ty);		};						/**		*			*/		private function doLerpAnimation(creature:LivingObject, mx:int, my:int, nDelay:int = 6, oParams:* = null):void		{			// does the hero want to move?			var bLerpX:Boolean = false;			var bLerpY:Boolean = false;						var bx:Number = 32;			// beginning x value.			var cx:Number = -32;		// change in x value			var by:Number = 32;			// beginning y value.			var cy:Number = -32;		// change in y value.			var tw:int = RenderDefines.TILE_WIDTH;	// tile width			var th:int = RenderDefines.TILE_HEIGHT; // tile height						// this is the second time we're checking this shit. nececessary?			if ( mx != 0 )			{				bLerpX = true;				if ( mx > 0 )				{					bx = 0 - tw;					cx = tw;				}				else				{					bx = tw;					cx = 0 - tw;				}			}						// this is the second time we're checking this shit. nececessary?			if ( my != 0 )			{				bLerpY = true;				if ( my > 0 )				{					by = 0 - th;					cy = th;				}				else				{					by = th;					cy = 0 - th;				}			}						// Now check to see if they are moving diagonally or just in one direction.			// If they're moving diagonally, the duration is goign to take a bit longer since they're walking a greater distance			if ( bLerpX && bLerpY )			{				// increase duration since they're moving diagonal.				nDelay *= 1.4;				initLerp(_oLerpX, creature, bx, cx, 0, nDelay, oParams);				initLerp(_oLerpY, creature, by, cy, 0, nDelay, oParams);			}			else if (bLerpX)			{				initLerp(_oLerpX, creature, bx, cx, 0, nDelay, oParams);				}			else if ( bLerpY )			{				initLerp(_oLerpY, creature, by, cy, 0, nDelay, oParams);			}		};						/**		*	Initializes a lerp machine.		*/		private function initLerp(lerpMachine:LerpMachine, c:Object, startValue:Number, changeInValue:Number, currentStep:int, duration:int, oParams:* = null):void		{			//trace("InGameManager::initLerp()");			switch(lerpMachine)			{				case _oLerpX :					_bLerpX = true;				break;				case _oLerpY :					_bLerpY = true;				break;			}			lerpMachine.oParams = oParams;			lerpMachine.reset(c, startValue, changeInValue, currentStep, duration)		};				private function updateAttackLerp(lerpMachine:LerpMachine):void		{			trace("InGameManager::updateAttackLerp()");					};				/**		*	Updates lerp machines		*/		private function updateLerps():void		{			if (_oLerpX.oParams != null)			{				_oLerpX.step();				switch (_oLerpX.oParams.type)				{					case 0 :						updateAttackLerp(_oLerpX);					break;					default :						trace("InGameManager::updateLerps() -> unknown lerp type!");					break;				}			}			else			{				// update the lerpers				if ( _oLerpX.target != null ) _oLerpX.step();				if ( _oLerpY.target != null ) _oLerpY.step();							if (_bLerpX)				{					// is this lerp done?					if ( _oLerpX.complete )					{						// is this lerp related to the current monster?						if ( _oLerpX.target == _oCurrentMonster )						{							/*							if ( _oCurrentMonster != null ) {								_oCurrentMonster.oDimensions.x = _oCurrentCreatureTarget.x								_oCurrentMonster.oDimensions.y = _oCurrentCreatureTarget.y							}							*/													// if the mobile is moving diagonally, we need to check the status of the OTHER lerper handling x movment.							// if that one doesn't have the current monster assigned to it, then we should be done!							// if we don't do this check, weird things can happen if you press quickly press another direction while your character is moving diagonally.							// for example, if you're moving north-east, hold down east while moving and you will see your character skip an animation.							if ( _oLerpY.target != _oCurrentMonster )							{								_oCurrentMonster = null;							}													// unassign this lerp's target so others will know we're done animating.							_oLerpX.target = null;						}					}				}							if (_bLerpY)				{					// is this lerp done?					if ( _oLerpY.complete )					{						// is this lerp related to the current monster?						if ( _oLerpY.target == _oCurrentMonster )						{							/*							if ( _oCurrentMonster != null ) {								_oCurrentMonster.oDimensions.x = _oCurrentCreatureTarget.x								_oCurrentMonster.oDimensions.y = _oCurrentCreatureTarget.y							}							*/													// if the mobile is moving diagonally, we need to check the status of the OTHER lerper handling x movment.							// if that one doesn't have the current monster assigned to it, then we should be done!							// if we don't do this check, weird things can happen if you press quickly press another direction while your character is moving diagonally.							// for example, if you're moving north-east, hold down east while moving and you will see your character skip an animation.							if ( _oLerpX.target != _oCurrentMonster )							{								_oCurrentMonster = null;							}							// unassign this lerp's target so others will know we're done animating.							_oLerpY.target = null;						}					}				}			}					};						/**		*	Generic render function reroutes rendering process based on preferred settings.		*/		private function render():void		{			if ( _oBitmapRenderer != null ) {				bitmapRender();			} else {				vectorRender();			}		};						/**		*	Updates Bitmap renderer.			*/		private function bitmapRender():void		{						// reset camera			_oCamera.bUpdated = false;						if ( _oHero != null )			{				if ( _oHero.oPhysicalObject != null )				{					if ( _oLerpX.oParams != null )					{						if ( _oLerpX.complete )						{							// is this lerp related to the current monster?							if ( _oLerpX.target == _oCurrentMonster )							{								trace("InGameManager::updateAttackLerp() LERP RESET");								_oCurrentMonster.nCurrentAction = Action.NONE								_oCurrentMonster = null;								_oLerpX.oParams = null;															}						}					}					else					{						var camX:Number = _oHero.oPhysicalObject.oDimensions.x * RenderDefines.TILE_WIDTH;						var camY:Number = _oHero.oPhysicalObject.oDimensions.y * RenderDefines.TILE_HEIGHT;						if (_oLerpX.target == _oHero.oPhysicalObject) camX += _oLerpX.currentValue;						if (_oLerpY.target == _oHero.oPhysicalObject) camY += _oLerpY.currentValue;						_oCamera.focusOn(camX, camY);					}				}			}												/*			// follows each monster!			// Fri Oct  9 12:47:56 CDT 2009 CMD TODO: This block of code is flawed, I think. It doesn't appear to render every monster.			if ( _oCurrentMonster != null )			{					var camX:Number = _oCurrentMonster.tx * RenderDefines.TILE_WIDTH;					var camY:Number = _oCurrentMonster.ty * RenderDefines.TILE_HEIGHT;					if (_oLerpX.target == _oCurrentMonster) camX += _oLerpX.currentValue;					if (_oLerpY.target == _oCurrentMonster) camY += _oLerpY.currentValue;					_oCamera.focusOn(camX, camY);			}			*/			// DRAW MINIMAP			if ( _oMinimapContainer.visible ) _oMinimapRenderer.vUpdate();						// DRAW MAP			//if ( _oCamera.bUpdated )				_oBitmapRenderer.viewUpdate(_oCamera.nViewOffsetX,_oCamera.nViewOffsetY);				_oBitmapRenderer.drawTiles(_oFloorMap.tiles, _bmdTileSet as BitmapData);						// DRAW TRAPS			//_oBitmapRenderer.renderGroup(_oFloorMap.traps, _bmdTrapSheet);						// DRAW ITEMS			_bmdItems.fillRect(_rectRenderLayer, 0x00000000);			_oBitmapRenderer.renderGroup(_bmdItems, _oFloorMap.items);						// DRAW CHARACTERS			_bmdSprites.fillRect(_rectRenderLayer, 0x00000000);			_oBitmapRenderer.renderGroup(_bmdSprites, _oFloorMap.monsters);						// VFX 1			_bmdVFX.fillRect(_rectRenderLayer, 0x00000000);			_oBitmapRenderer.renderGroup(_bmdVFX, null);		};						/**		*	Updates vector renderer.		*/		private function vectorRender():void		{					};						//============================================		//	KEYBOARD INPUT - SUPER TEMPORARY UNTIL I CAN HOOK UP REMAPPABLE KEYS!!!!		//	REMAPPABLE KEY PROTOYPE IS DONE.		//	GOTTA MAKE AN INPUT MANAGER CLASS!!!!		//============================================				private function vHandle_this_KEY_DOWN(evt:KeyboardEvent):void		{			//trace( evt.keyCode );						switch ( evt.keyCode )			{				case 82 : // R					//if ( evt.shiftKey ) // shift r is pressed				break;								/*				case 188 : // comma					if (_anPreviousFloorSteps.length > 1) restoreMap(_anPreviousFloorSteps.length - 2)				break;				*/								case 77 : // m					//vToggleMinimap();				break;								/*				case 190 : // period					_anPreviousFloorSteps.push(_oMersenneTwister_Maps.step);					_anPreviousMonsterSteps.push(_oMersenneTwister_Monsters.step);					_anPreviousItemSteps.push(_oMersenneTwister_Items.step);					//trace(_anPreviousFloorSteps);					buildMap(_aoMapData);				break;				*/			};			};				private function vHandle_this_KEY_UP(evt:KeyboardEvent):void		{			switch ( evt.keyCode )			{				default :					//				break;			};		};								//============================================		//	// Fri Sep 25 21:06:16 CDT 2009 CMD TODO: THIS CONTROL NEEDS TO BE ELSEWHERE!		//	// perhaps there should be a class that manages the minimap!!!		//	// the minimap manager would need a reference to the display object holding the minimap so it could toggle its visiblity		//	// as well as draw to the minimap!		//===========================================		public function vToggleMinimap():void		{			if ( _bBitmapRenderingEnabled )			{				_oMinimapContainer.visible = !_oMinimapContainer.visible;			}			else			{				_oMinimapSprite.visible = !_oMinimapSprite.visible;			}		}				public function vToggleGameView():void		{			_oGameContainer.visible = !_oGameContainer.visible;		}	}}internal class SingletonEnforcer{};