/////////////////////////////////////////////////////	MapData//	CREATED: 2009-08-14.//	BY: CHASE DE LANGUILLETTE - chase.delanguillette@gmail.com////	CLASS RESPONSIBILITES://////////////////////////////////////////////////////package com.chasedelanguillette.roguish.editor.roomEditor{	//============================================	//	CUSTOM IMPORTS	//============================================	import com.chasedelanguillette.utils.ArrayUtils;	import com.chasedelanguillette.utils.MersenneTwister;	import com.chasedelanguillette.roguish.maps.sections.Room;			//============================================	//	STANDARD IMPORTS	//============================================	import flash.geom.Rectangle;		public class MapData extends Object	{				//============================================		//	CONSTANTS		//============================================				public static const MAP_TYPE_DUNGEON:int = 1;		public static const MAP_TYPE_STREETS:int = 2;		public static const MAP_TYPE_CAVES:int = 4;				public static const MAP_TYPE_MYSTERY_DUNGEON:int = MAP_TYPE_DUNGEON | MAP_TYPE_CAVES;		public static const MAP_TYPE_ALL:int = 0xffffffff;				public static const MAP_TYPES:Array = [MAP_TYPE_DUNGEON, MAP_TYPE_STREETS, MAP_TYPE_CAVES, MAP_TYPE_MYSTERY_DUNGEON, MAP_TYPE_ALL];				public static function getMapTypeName(type:int):String		{			switch (type)			{				case MAP_TYPE_DUNGEON: 				return "Dungeon"; break;				case MAP_TYPE_STREETS: 				return "Streets"; break;				case MAP_TYPE_CAVES: 				return "Caves"; break;				case MAP_TYPE_MYSTERY_DUNGEON: 		return "Mystery Dungeon"; break;				case MAP_TYPE_ALL: 					return "Hodge Podge"; break;			}						return "???";		}				public static function getMapTypeDescription(type:int):String		{			switch (type)			{				case MAP_TYPE_DUNGEON: 				return "A basic dungeon."; break;				case MAP_TYPE_STREETS: 				return "Segments for zombie apocalpyse."; break;				case MAP_TYPE_CAVES: 				return "For creating organic, underground mazes."; break;				case MAP_TYPE_MYSTERY_DUNGEON: 		return "A blend of caves & dungeon segments."; break;				case MAP_TYPE_ALL: 					return "A mix of all segment types."; break;			}						return "???";		}										//============================================		//	PUBLIC VARS		//============================================				private var _rooms:Array; // array of rectangles		private var _exits:Array; // array of rectangles		private var _tiles:Array; // 2d array of tile data (ideally ints)		public var rotations:int;		public var reflectH:Boolean;		public var reflectV:Boolean;		public var occupiedList:Array = new Array();		public var mapTypeMask:int = 0;						//============================================		//	PRIVATE VARS		//============================================										//////////////////////////////////////////////		//		//	CONSTRUCTOR		//		//////////////////////////////////////////////				public function MapData(tiles:Array, roomRegions:Array, exits:Array):void		{			this._rooms = roomRegions;			this._exits = exits;			this._tiles = tiles;						/*			for ( var i:int = 0; i < this._rooms.length; i++ )			{				var r:Room = this._rooms[i];								for (var j:int = 0; j < r.height; j++)				{					for (var j:int = 0; j < r.width; j++)					{											}				}			}			*/		};				//============================================		//	publics		//============================================				public function cleanUp():void		{			if (_rooms != null )			{				for (var i:int = 0; i < _rooms.length; i++)				{					_rooms[i] = null;				}				_rooms = null;			}						if (_exits != null)			{				for (var nExitIndex:int = 0; nExitIndex < _exits.length; nExitIndex++)				{					_exits[nExitIndex] = null;				}				_exits = null;			}			if (_tiles != null)			{				for (var nTileIndex:int = 0; nTileIndex < _tiles.length; nTileIndex++)				{					_tiles[nTileIndex] = null;				}				_tiles = null;			}		}				// copies existing map data object and returns a new mapdata instance!		public static function oCopyMapData(oMapData:MapData):MapData		{			var rooms:Array = MapData.aoCopyRegions(oMapData.rooms);//ArrayUtils.aoCopyArray(oMapData.rooms);			var exits:Array = MapData.aoCopyRegions(oMapData.exits);//ArrayUtils.aoCopyArray(oMapData.exits);			var tiles:Array = ArrayUtils.aoCopyArray(oMapData.tiles);			var m:MapData = new MapData(tiles, rooms, exits);			m.rotations = oMapData.rotations;			return m;		}				public function randomlyTransformRoom(randomNumberGenerator:MersenneTwister):void		{									//trace("rotating room " + rotation + " times")			var w:int, h:int;						var rotation:int = Math.floor(MersenneTwister.nGenerateRandomFloatFromInstance(randomNumberGenerator) * 4);			rotations = rotation;			switch (rotation)			{				case 0 :					// rotation none				break;				case 1 :					// rotate 90					rotateRoomRight();				break;				case 2 :					// rotate 180					rotateRoomRight();					rotateRoomRight();				break;				case 3 :					// rotate 270					rotateRoomRight();					rotateRoomRight();					rotateRoomRight();				break;			}									var reflect_h:int = Math.floor(MersenneTwister.nGenerateRandomFloatFromInstance(randomNumberGenerator) * 2);			reflectH = false;			if ( reflect_h == 0 ) {				//trace( "flipping room horizontally" )				reflectRoomHorizontal();//transformedArray = aoFlipHorizontal(transformedArray);				reflectH = true;			}						var reflect_v:int = Math.floor(MersenneTwister.nGenerateRandomFloatFromInstance(randomNumberGenerator) * 2);			reflectV = false;			if ( reflect_v == 0 ) {				//trace( "flipping room vertically" )								reflectRoomVertical();//transformedArray = aoFlipVertical(transformedArray);				reflectV = true;			}					};				public static function aoCopyRegions(regions:Array):Array		{			var newArr:Array = new Array();			for (var i:int = 0; i < regions.length; i++)			{				var region:Room = regions[i];				var newRegion:Room = new Room(region.x, region.y, region.width, region.height);				newArr[i] = newRegion;				}			return newArr;		};						//============================================		//	gets for exit regions!		//============================================				public static function getExitNorth(room:MapData):Room		{			room.exits.sortOn("y", Array.NUMERIC);			return room.exits[0];		};				public static function getExitSouth(room:MapData):Room		{			room.exits.sortOn("y", Array.NUMERIC | Array.DESCENDING);			return room.exits[0];			/*			var sortedArray:Array = new Array()			sortedArray.push(room.exits[0]);			for (var i:int = 1; i < 4; i++)			{				var exit:Room = room.exits[i];								if ( exit.y + exit.height > sortedArray[0].y + sortedArray[0].width ) sortedArray.unshift(exit);			}						return sortedArray[0]			*/					};				public static function getExitEast(room:MapData):Room		{			room.exits.sortOn("x", Array.NUMERIC | Array.DESCENDING);			return room.exits[0];			/*			var sortedArray:Array = new Array()			sortedArray.push(room.exits[0]);			for (var i:int = 1; i < 4; i++)			{				var exit:Room = room.exits[i];				if ( exit.x + exit.width > sortedArray[0].x + sortedArray[0].width ) sortedArray.unshift(exit);			}						return room.exits[0];			*/			};				public static function getExitWest(room:MapData):Room		{			room.exits.sortOn("x", Array.NUMERIC);			return room.exits[0];		};						//============================================		//	getters		//============================================				public function get rooms():Array{			return _rooms;		};				public function set rooms(value:Array):void {			_rooms = value;		};				public function get exits():Array{			return _exits;		};				public function get tiles():Array{			return _tiles;		}				//============================================		//	room rotation - clockwise		//============================================				private function rotateRoomRight():void		{			// rotate the regions first!			//var w:int = this._tiles[0].length;			var h:int = this._tiles.length;			rotateRegionsRight(this._rooms, h);			rotateRegionsRight(this._exits, h);			// now rotate the tiles!			this._tiles = ArrayUtils.aoRotateRight(this._tiles);		};				private static function rotateRegionsRight(regions:Array, nRoomHeight:int):void		{			for (var i:int = 0; i < regions.length; i++)			{				regions[i] = rotateRoomRight(regions[i], nRoomHeight);				//rotateRoomRight(regions[i], nRoomHeight);			}		};				private static function rotateRoomRight(rectangle:Room, nRoomHeight:int):Room		{			var x:Number = nRoomHeight - ( rectangle.height + rectangle.y );			var y:Number = rectangle.x;			var w:Number = rectangle.height;			var h:Number = rectangle.width;			return new Room(x, y, w, h);		};						//============================================		//	room rotation - counter clockwise		//============================================				//============================================		//	horizontal reflection		//============================================		private function reflectRoomHorizontal():void		{			var w:int = this._tiles[0].length;			reflectRegionsHorizontal(this._rooms, w);			reflectRegionsHorizontal(this._exits, w);			this._tiles = ArrayUtils.aoFlipHorizontal(this._tiles);		};				private static function reflectRegionsHorizontal(regions:Array, nRoomWidth:int):void		{			for (var i:int = 0; i < regions.length; i++)			{				//reflectRegionHorizontal(regions[i], nRoomWidth);				regions[i].x = nRoomWidth - (regions[i].x + regions[i].width);			}		};				private static function reflectRegionHorizontal(region:Room, nRoomWidth:int):void		{			region.x = nRoomWidth - (region.x + region.width);		};						//============================================		//	vertical reflection		//============================================				private function reflectRoomVertical():void		{			var h:int = this._tiles.length;			reflectRegionsVertical(this._rooms, h);			reflectRegionsVertical(this._exits, h);			this._tiles = ArrayUtils.aoFlipVertical(this._tiles);		};				private static function reflectRegionsVertical(regions:Array, nRoomHeight:int):void		{			for (var i:int = 0; i < regions.length; i++)			{				//reflectRegionVertical(regions[i], nRoomHeight);				regions[i].y = nRoomHeight - (regions[i].y + regions[i].height);			}		};				private static function reflectRegionVertical(region:Room, nRoomHeight:int):void		{			region.y = nRoomHeight - (region.y + region.height);		};					}}